// Generated by CoffeeScript 1.6.3
(function() {
  var assert, sq;

  if (typeof require !== "undefined" && require !== null) {
    sq = require('../stack-queue.js');
    global.Stack = sq.Stack;
    global.Queue = sq.Queue;
  }

  assert = {
    equal: function(x, y) {
      if (x !== y) {
        throw Error("assertion failed: " + x + " does not equal " + y);
      }
    },
    "false": function(x) {
      if (x !== false) {
        throw Error("assertion failed: " + x + " should be false");
      }
    },
    "true": function(x) {
      if (x !== true) {
        throw Error("assertion failed: " + x + " should be true");
      }
    }
  };

  describe('Basic Methods', function() {
    describe('stack(value) / stack.push(value) / stack.add(value)', function() {
      it('should increment size with each new value from call to self', function() {
        var after, before, stack;
        stack = Stack();
        before = stack.size();
        stack('foo');
        stack('bar');
        after = stack.size();
        assert.equal(before, 0);
        return assert.equal(after, 2);
      });
      it('should increment size with each new value from call to push', function() {
        var after, before, stack;
        stack = Stack();
        before = stack.size();
        stack.push('foo', 'bar', 'boo');
        after = stack.size();
        assert.equal(before, 0);
        return assert.equal(after, 3);
      });
      return it('should increment size with each new value from call to add', function() {
        var after, before, stack;
        stack = Stack();
        before = stack.size();
        stack.add('foo');
        after = stack.size();
        assert.equal(before, 0);
        return assert.equal(after, 1);
      });
    });
    describe('stack() / stack.pop() / stack.get()', function() {
      it('should decrement size with each call to stack()', function() {
        var after, before, stack;
        stack = Stack()('foo');
        before = stack.size();
        stack();
        stack();
        after = stack.size();
        assert.equal(before, 1);
        return assert.equal(after, 0);
      });
      it('should decrement size with each call to stack.pop()', function() {
        var after, before, stack;
        stack = Stack()('foo', 'bar');
        before = stack.size();
        stack.pop();
        after = stack.size();
        assert.equal(before, 2);
        return assert.equal(after, 1);
      });
      it('should decrement size with each call to stack.get()', function() {
        var after, before, stack;
        stack = Stack()('foo', 'bar', 'boo');
        before = stack.size();
        stack.get();
        stack.get();
        after = stack.size();
        assert.equal(before, 3);
        return assert.equal(after, 1);
      });
      return it('should return undefined when the stack is empty', function() {
        var stack;
        stack = Stack();
        assert.equal(stack.get(), void 0);
        stack.add('foo').get();
        return assert.equal(stack.get(), void 0);
      });
    });
    return describe('stack.toString()', function() {
      return it('should return the same string as Array.toString()', function() {
        var a, stack;
        stack = Stack();
        a = [124, 'foo', 564];
        stack.push.apply(stack, a);
        return assert.equal(stack.toString(), a.toString());
      });
    });
  });

  describe('Stack Specific Methods', function() {
    it('should return values in FILO order', function() {
      var data, stack;
      data = [34, 48, 19];
      stack = Stack();
      stack(data[0]).push(data[1]).add(data[2]);
      assert.equal(stack(), data[2]);
      assert.equal(stack.pop(), data[1]);
      return assert.equal(stack.get(), data[0]);
    });
    return describe('stack.peek()', function() {
      return it('should return last value without mutating the stack', function() {
        var data, stack;
        data = [34, 48, 19];
        stack = Stack().apply(null, data);
        assert.equal(stack.peek(), data[2]);
        assert.equal(stack.peek(), stack());
        return assert.equal(stack.peek(), data[1]);
      });
    });
  });

  describe('Queue Specific Methods', function() {
    it('should return values in FIFO order', function() {
      var data, queue;
      data = [34, 48, 19];
      queue = Queue();
      queue(data[0]).push(data[1]).add(data[2]);
      assert.equal(queue(), data[0]);
      assert.equal(queue.shift(), data[1]);
      return assert.equal(queue.get(), data[2]);
    });
    return describe('queue.peek()', function() {
      return it('should return first value without mutating the queue', function() {
        var data, queue;
        data = [34, 48, 19];
        queue = Queue().apply(null, data);
        assert.equal(queue.peek(), data[0]);
        assert.equal(queue.peek(), queue());
        return assert.equal(queue.peek(), data[1]);
      });
    });
  });

  describe('Events', function() {
    describe('overflow', function() {
      it('should fire overflow event when maxSize is reached', function() {
        var fired, queue;
        fired = false;
        queue = Queue(5).on('overflow', function() {
          return fired = true;
        });
        queue(12, 45, 29, 'foo', 'bar');
        assert["false"](fired);
        queue(334);
        return assert["true"](fired);
      });
      return it('should pass value which was added to overflow handler', function() {
        var overflowValue, queue;
        overflowValue = 344;
        queue = Queue(3)(12, 45, 29).on('overflow', function(value) {
          return assert.equal(value, overflowValue);
        });
        return queue(overflowValue);
      });
    });
    describe('empty', function() {
      return it('should fire empty event when last value is removed', function() {
        var fired, queue;
        fired = false;
        queue = Queue(5).on('empty', function() {
          return fired = true;
        });
        queue(12, 45);
        queue();
        assert["false"](fired);
        queue();
        return assert["true"](fired);
      });
    });
    describe('queue.on(eventName, callback)', function() {
      return it('should allow multiple callbacks for the same event', function() {
        var firedCounts, queue;
        firedCounts = [0, 0];
        queue = Queue(5).on('empty', function() {
          return firedCounts[0]++;
        });
        queue.on('empty', function() {
          return firedCounts[1]++;
        });
        queue(7)();
        queue();
        return assert.equal(firedCounts[0], firedCounts[1]);
      });
    });
    return describe('queue.off(eventName, callback)', function() {
      return it('should not call callback after it has been removed', function() {
        var callback, firedCount, queue;
        firedCount = 0;
        callback = function() {
          return firedCount++;
        };
        queue = Queue(5).on('empty', callback);
        queue(15)();
        queue.off('empty', callback);
        queue(12)();
        return assert.equal(firedCount, 1);
      });
    });
  });

}).call(this);
